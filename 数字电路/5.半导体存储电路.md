![[Pasted image 20230303195218.png]]
## 锁存器和触发器
- 锁存器：电平触发
- 触发器：边沿触发


### SR锁存器和触发器：
$$
\begin{align*}
&Q^*=S+R'Q
\\\\
&SR=0
\end{align*}
$$
![[Pasted image 20230308105144.png|350]]![[Pasted image 20230308105222.png|350]]



### D触发器：
- 由SR触发器，S端接反相器之后连到R端
$$
Q^*=CD+C'Q
$$
![[Pasted image 20230308112012.png|400]]![[Pasted image 20230308112109.png|250]]

![[Pasted image 20230308112835.png|550]]

### 集成触发器
<font color=red>集成D触发器中有两片带有异步清零、置数的D触发器</font>
引脚：
- 清零引脚
- 置数引脚
![[Pasted image 20230309102126.png|400]]

## 描述触发器的方式
- 特征方程
- 功能表
- 状态表（真值表）
- 波形图

### 功能表
- 只需要根据触发器的输入，描述出对于功能即可
- <font color=red>触发器的功能无非只有置0，置1，保持，翻转这四种</font>

| J   | K   | 功能 |
| --- | --- | ---- |
| 0   | 0   | 保持 |
| 0   | 1   | 置0  |
| 1   | 0   | 置1  |
| 1   | 1   | 翻转     |

### 状态表
- 根据输入的触发器的组合以及初态写出次态
| J   | K   | Q   | QN  |
| --- | --- | --- | --- |
| 0   | 0   | 0   | 0   |
| 0   | 0   | 1   | 1   |
| 0   | 1   | 0   | 0   |
| 0   | 1   | 1   | 0   |
| 1   | 0   | 0   | 1   |
| 1   | 0   | 1   | 1   |
| 1   | 1   | 0   | 1   |
| 1   | 1   | 1   | 0    |

## 不同触发器之间的转换
- 公式法
- 真值表法

### 公式法
- 写出带设计触发器的真值表，用卡诺图化简得逻辑表达式
- 将待设计的触发器特征方程凑成已知触发器的特征方程形式
SR触发器：$Q^*=S+R'Q$
JK触发器：$Q^*=JQ'+K'Q$
D触发器：$Q^*=D$
T触发器：$Q^*=T\oplus Q$


### 真值表法
假设用T触发器构造JK触发器
将JK触发器和T触发器的状态表写成一张状态表，取Q，J，K，T为真值表式样
用卡诺图进行化简得到$T=f(J,K)$
依据得到的逻辑表达式画出逻辑图

### 几种常见触发器之间的转换
#### RS-->JK
- S=JQ',R=KQ
#### JK-->RS
- J=S,K=R
#### RS-->D
- S=D,R=D'
D-->RS
- D=S+R'Q
#### RS-->T
- S=TQ',R=TQ
T-->RS
- T=SQ'+RQ
#### JK-->D
- J=D,K=D'
#### D-->JK
- D=JQ'+K'Q
#### JK-->T
- J=T,K=T
#### T-->JK
- T=JQ'+KQ
#### T-->D
- $T=D\oplus Q$ 
#### D-->T
- $D=T\oplus Q$

## 存储器
- ROM:(Read-Only Memory)
- RAM:(Random Access Memory)
- <font color=red>存储容量用“字×位”</font>
- 存取时间：从开始存取第一个数据到能够开始存取第二个数据所用的时间


### ROM
- n输入b输出的组合逻辑电路
- n输入：地址线n根，字数$2^n$，可寻址范围$0-(2^n-1)$
- b输出：数据线b根，位数为b
- 存储单元数=$2^n\cdot b$
- <font color=red>可用来实现组合逻辑电路</font>


### RAM
- 可以在任何时刻对存储器内的任意一个单元直接存入（写）或取出（读）信息
- 为静态存储器SRAM（由锁存器组成）和动态存储器 DRAM（由动态 MOS 存储单元组成）

### 堆栈
堆栈电路的工作原理是使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）。推入是将数据放入堆栈顶端，堆栈顶端移到新放入的数据。弹出是将堆栈顶端数据移除，堆栈顶端移到移除后的下一笔数据。

满栈（full stack）：当堆栈指针指向最后压入栈的数据。
空栈（empty stack）：当堆栈指针指向下一个将要放入数据的位置。

<font color=red>可以通过检查堆栈指针来辨识什么是满栈，什么是空栈。</font>
 
### RAM（ROM）容量的扩展
### 位扩展
扩展存储器每一个地址所存储的数据宽度
<font color=blue>扩展方法：将每一片的地址位、片选位、读写位均接到一起</font>
![[Pasted image 20230308140145.png|500]]

### 字扩展
扩展存储器的地址宽度
扩展方法：
- 多出的地址线通过译码器控制输出控制每块芯片片选，使之每次选通一个
- 共享数据位
- 读写线采用线与
![[Pasted image 20230308140748.png|700]]


## 例题
### 画波形
### 门电路无延时


### 门电路有延时
1. 延时相对时钟周期及其小：

2. 延时和时钟分段时间一样
	- 拆分成单个门电路，每次只分析一个门电路的延迟
	- 拆分成单个门电路之后分析，初始状态与第一次延时后状态相同
	- 对于Q和QN的分析，默认Q初态0，QN初态1，然后==交替取值==去分析


<font color=red>考虑传输延迟时间（有两个门电路），输入同时从有效到无效会发生震荡</font>
![[Pasted image 20230308201528.png|650]]
![[Pasted image 20230308201633.png|620]]

<font color=red>考虑触发器和门电路的延迟，异步清零同样算上触发器的延时</font>
![[Pasted image 20230309094547.png|650]]

![[Pasted image 20230309094754.png|600]]

<font color=red>先根据SR波形得出Q波形，在SQ得出Q'波形</font>
- Q与Q'在考虑触发器时延的情况下即便不出现11波形也不再互补
- 对于Q波形，SR中01和10的延迟是不相同的，可能历经一个延迟，可能历经两个，具体问题具体分析
![[Pasted image 20230309104447.png|600]]
![[Pasted image 20230309104520.png|350]]
### 触发器之间的转换
<font color=red>触发器之间的转换：凑公式法，真值表</font>
![[Pasted image 20230308205524.png|600]]


请说明如何用一个 74×74 正边沿触发式 D 触发器（不用其他元件）来构造 S-R锁存器。
![[Pasted image 20230309103139.png|250]]

### 存储器的扩展
某存储器芯片的容量为16K\*8bits则其地址位码有多少位？如果用该芯片构造64K\*32位的存储器，需要多少片这样的芯片?

$$
\begin{align*}
&16k=2^{14},故需要14根线
\\\\
&64k=2^{16},要16根地址线,所以要用一个2-4译码器扩展,就需要4片将其扩展成64*8bits
\\\\
&8bits\rightarrow 32bits,需要多4个8bits芯片
\\\\
&综上:4*4=16,需要16片16k*8bits
\end{align*}
$$

### 存储器构建电路
试用 ROM 和 T 触发器实现同步格雷码模 8 计数器。要求：
1）需要选用存储容量是多少的 ROM；
2）设计电路并写出该 ROM 的存储内容。
![[Pasted image 20230320172333.png|700]]
![[Pasted image 20230320172428.png|650]]